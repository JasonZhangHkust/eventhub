// Code generated by protoc-gen-go. DO NOT EDIT.
// source: EventHub.proto

/*
Package predix is a generated protocol buffer package.

It is generated from these files:
	EventHub.proto

It has these top-level messages:
	Timestamp
	Message
	Ack
	Messages
	PublishRequest
	PublishResponse
	SubscriptionResponse
	SubscriptionRequest
*/
package predix

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AckStatus int32

const (
	AckStatus_ACCEPTED          AckStatus = 0
	AckStatus_BAD_REQUEST       AckStatus = 1
	AckStatus_REQUEST_TOO_LARGE AckStatus = 2
	AckStatus_FAILED            AckStatus = 3
)

var AckStatus_name = map[int32]string{
	0: "ACCEPTED",
	1: "BAD_REQUEST",
	2: "REQUEST_TOO_LARGE",
	3: "FAILED",
}
var AckStatus_value = map[string]int32{
	"ACCEPTED":          0,
	"BAD_REQUEST":       1,
	"REQUEST_TOO_LARGE": 2,
	"FAILED":            3,
}

func (x AckStatus) String() string {
	return proto.EnumName(AckStatus_name, int32(x))
}
func (AckStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Timestamp struct {
	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds int64 `protobuf:"varint,1,opt,name=seconds" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive.
	Nanos int32 `protobuf:"varint,2,opt,name=nanos" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

type Message struct {
	Id        string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Body      []byte            `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	ZoneId    string            `protobuf:"bytes,3,opt,name=zone_id,json=zoneId" json:"zone_id,omitempty"`
	Tags      map[string]string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Key       []byte            `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	Topic     string            `protobuf:"bytes,6,opt,name=topic" json:"topic,omitempty"`
	Partition int32             `protobuf:"varint,7,opt,name=partition" json:"partition,omitempty"`
	Offset    int64             `protobuf:"varint,8,opt,name=offset" json:"offset,omitempty"`
	Timestamp *Timestamp        `protobuf:"bytes,9,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Message) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Message) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Message) GetZoneId() string {
	if m != nil {
		return m.ZoneId
	}
	return ""
}

func (m *Message) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Message) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Message) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Message) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *Message) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Message) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type Ack struct {
	Id         string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	StatusCode AckStatus         `protobuf:"varint,2,opt,name=status_code,json=statusCode,enum=predix.AckStatus" json:"status_code,omitempty"`
	Desc       string            `protobuf:"bytes,3,opt,name=desc" json:"desc,omitempty"`
	Topic      string            `protobuf:"bytes,4,opt,name=topic" json:"topic,omitempty"`
	Partition  int32             `protobuf:"varint,5,opt,name=partition" json:"partition,omitempty"`
	Offset     int64             `protobuf:"varint,6,opt,name=offset" json:"offset,omitempty"`
	Timestamp  *Timestamp        `protobuf:"bytes,7,opt,name=timestamp" json:"timestamp,omitempty"`
	Body       []byte            `protobuf:"bytes,8,opt,name=body,proto3" json:"body,omitempty"`
	ZoneId     string            `protobuf:"bytes,9,opt,name=zone_id,json=zoneId" json:"zone_id,omitempty"`
	Tags       map[string]string `protobuf:"bytes,10,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Key        []byte            `protobuf:"bytes,11,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (m *Ack) String() string            { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Ack) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Ack) GetStatusCode() AckStatus {
	if m != nil {
		return m.StatusCode
	}
	return AckStatus_ACCEPTED
}

func (m *Ack) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *Ack) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Ack) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *Ack) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Ack) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Ack) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Ack) GetZoneId() string {
	if m != nil {
		return m.ZoneId
	}
	return ""
}

func (m *Ack) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Ack) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type Messages struct {
	Msg []*Message `protobuf:"bytes,1,rep,name=msg" json:"msg,omitempty"`
}

func (m *Messages) Reset()                    { *m = Messages{} }
func (m *Messages) String() string            { return proto.CompactTextString(m) }
func (*Messages) ProtoMessage()               {}
func (*Messages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Messages) GetMsg() []*Message {
	if m != nil {
		return m.Msg
	}
	return nil
}

type PublishRequest struct {
	Messages *Messages `protobuf:"bytes,1,opt,name=messages" json:"messages,omitempty"`
}

func (m *PublishRequest) Reset()                    { *m = PublishRequest{} }
func (m *PublishRequest) String() string            { return proto.CompactTextString(m) }
func (*PublishRequest) ProtoMessage()               {}
func (*PublishRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PublishRequest) GetMessages() *Messages {
	if m != nil {
		return m.Messages
	}
	return nil
}

type PublishResponse struct {
	Ack []*Ack `protobuf:"bytes,1,rep,name=ack" json:"ack,omitempty"`
}

func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }
func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()               {}
func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PublishResponse) GetAck() []*Ack {
	if m != nil {
		return m.Ack
	}
	return nil
}

type SubscriptionResponse struct {
	Ack []*Ack `protobuf:"bytes,1,rep,name=ack" json:"ack,omitempty"`
}

func (m *SubscriptionResponse) Reset()                    { *m = SubscriptionResponse{} }
func (m *SubscriptionResponse) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionResponse) ProtoMessage()               {}
func (*SubscriptionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SubscriptionResponse) GetAck() []*Ack {
	if m != nil {
		return m.Ack
	}
	return nil
}

type SubscriptionRequest struct {
	ZoneId     string `protobuf:"bytes,1,opt,name=zone_id,json=zoneId" json:"zone_id,omitempty"`
	Subscriber string `protobuf:"bytes,2,opt,name=subscriber" json:"subscriber,omitempty"`
	InstanceId string `protobuf:"bytes,3,opt,name=instance_id,json=instanceId" json:"instance_id,omitempty"`
}

func (m *SubscriptionRequest) Reset()                    { *m = SubscriptionRequest{} }
func (m *SubscriptionRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionRequest) ProtoMessage()               {}
func (*SubscriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SubscriptionRequest) GetZoneId() string {
	if m != nil {
		return m.ZoneId
	}
	return ""
}

func (m *SubscriptionRequest) GetSubscriber() string {
	if m != nil {
		return m.Subscriber
	}
	return ""
}

func (m *SubscriptionRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func init() {
	proto.RegisterType((*Timestamp)(nil), "predix.Timestamp")
	proto.RegisterType((*Message)(nil), "predix.Message")
	proto.RegisterType((*Ack)(nil), "predix.Ack")
	proto.RegisterType((*Messages)(nil), "predix.Messages")
	proto.RegisterType((*PublishRequest)(nil), "predix.PublishRequest")
	proto.RegisterType((*PublishResponse)(nil), "predix.PublishResponse")
	proto.RegisterType((*SubscriptionResponse)(nil), "predix.SubscriptionResponse")
	proto.RegisterType((*SubscriptionRequest)(nil), "predix.SubscriptionRequest")
	proto.RegisterEnum("predix.AckStatus", AckStatus_name, AckStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Publisher service

type PublisherClient interface {
	// Send message to topic. Topic name will be in URI
	Send(ctx context.Context, opts ...grpc.CallOption) (Publisher_SendClient, error)
}

type publisherClient struct {
	cc *grpc.ClientConn
}

func NewPublisherClient(cc *grpc.ClientConn) PublisherClient {
	return &publisherClient{cc}
}

func (c *publisherClient) Send(ctx context.Context, opts ...grpc.CallOption) (Publisher_SendClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Publisher_serviceDesc.Streams[0], c.cc, "/predix.Publisher/send", opts...)
	if err != nil {
		return nil, err
	}
	x := &publisherSendClient{stream}
	return x, nil
}

type Publisher_SendClient interface {
	Send(*PublishRequest) error
	Recv() (*PublishResponse, error)
	grpc.ClientStream
}

type publisherSendClient struct {
	grpc.ClientStream
}

func (x *publisherSendClient) Send(m *PublishRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *publisherSendClient) Recv() (*PublishResponse, error) {
	m := new(PublishResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Publisher service

type PublisherServer interface {
	// Send message to topic. Topic name will be in URI
	Send(Publisher_SendServer) error
}

func RegisterPublisherServer(s *grpc.Server, srv PublisherServer) {
	s.RegisterService(&_Publisher_serviceDesc, srv)
}

func _Publisher_Send_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PublisherServer).Send(&publisherSendServer{stream})
}

type Publisher_SendServer interface {
	Send(*PublishResponse) error
	Recv() (*PublishRequest, error)
	grpc.ServerStream
}

type publisherSendServer struct {
	grpc.ServerStream
}

func (x *publisherSendServer) Send(m *PublishResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *publisherSendServer) Recv() (*PublishRequest, error) {
	m := new(PublishRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Publisher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "predix.Publisher",
	HandlerType: (*PublisherServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "send",
			Handler:       _Publisher_Send_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "EventHub.proto",
}

// Client API for Subscriber service

type SubscriberClient interface {
	// Receive message from a topic, as a subscriber
	Receive(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Subscriber_ReceiveClient, error)
	ReceiveWithAcks(ctx context.Context, opts ...grpc.CallOption) (Subscriber_ReceiveWithAcksClient, error)
}

type subscriberClient struct {
	cc *grpc.ClientConn
}

func NewSubscriberClient(cc *grpc.ClientConn) SubscriberClient {
	return &subscriberClient{cc}
}

func (c *subscriberClient) Receive(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Subscriber_ReceiveClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Subscriber_serviceDesc.Streams[0], c.cc, "/predix.Subscriber/receive", opts...)
	if err != nil {
		return nil, err
	}
	x := &subscriberReceiveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Subscriber_ReceiveClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type subscriberReceiveClient struct {
	grpc.ClientStream
}

func (x *subscriberReceiveClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *subscriberClient) ReceiveWithAcks(ctx context.Context, opts ...grpc.CallOption) (Subscriber_ReceiveWithAcksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Subscriber_serviceDesc.Streams[1], c.cc, "/predix.Subscriber/receiveWithAcks", opts...)
	if err != nil {
		return nil, err
	}
	x := &subscriberReceiveWithAcksClient{stream}
	return x, nil
}

type Subscriber_ReceiveWithAcksClient interface {
	Send(*SubscriptionResponse) error
	Recv() (*Message, error)
	grpc.ClientStream
}

type subscriberReceiveWithAcksClient struct {
	grpc.ClientStream
}

func (x *subscriberReceiveWithAcksClient) Send(m *SubscriptionResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *subscriberReceiveWithAcksClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Subscriber service

type SubscriberServer interface {
	// Receive message from a topic, as a subscriber
	Receive(*SubscriptionRequest, Subscriber_ReceiveServer) error
	ReceiveWithAcks(Subscriber_ReceiveWithAcksServer) error
}

func RegisterSubscriberServer(s *grpc.Server, srv SubscriberServer) {
	s.RegisterService(&_Subscriber_serviceDesc, srv)
}

func _Subscriber_Receive_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriberServer).Receive(m, &subscriberReceiveServer{stream})
}

type Subscriber_ReceiveServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type subscriberReceiveServer struct {
	grpc.ServerStream
}

func (x *subscriberReceiveServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Subscriber_ReceiveWithAcks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SubscriberServer).ReceiveWithAcks(&subscriberReceiveWithAcksServer{stream})
}

type Subscriber_ReceiveWithAcksServer interface {
	Send(*Message) error
	Recv() (*SubscriptionResponse, error)
	grpc.ServerStream
}

type subscriberReceiveWithAcksServer struct {
	grpc.ServerStream
}

func (x *subscriberReceiveWithAcksServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func (x *subscriberReceiveWithAcksServer) Recv() (*SubscriptionResponse, error) {
	m := new(SubscriptionResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Subscriber_serviceDesc = grpc.ServiceDesc{
	ServiceName: "predix.Subscriber",
	HandlerType: (*SubscriberServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "receive",
			Handler:       _Subscriber_Receive_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "receiveWithAcks",
			Handler:       _Subscriber_ReceiveWithAcks_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "EventHub.proto",
}

func init() { proto.RegisterFile("EventHub.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 683 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0x6b, 0x6f, 0xd3, 0x3c,
	0x14, 0xc7, 0x97, 0xa6, 0xb7, 0x9c, 0x4c, 0x6d, 0xe7, 0x67, 0x97, 0x3c, 0x63, 0x40, 0xc9, 0xab,
	0x72, 0x59, 0x99, 0x8a, 0x10, 0x88, 0x09, 0xa4, 0x6e, 0xcb, 0x60, 0x68, 0xd3, 0x86, 0x5b, 0xc4,
	0xcb, 0x2a, 0x17, 0xaf, 0xb3, 0xba, 0xc6, 0x21, 0x76, 0x2a, 0xc6, 0xb7, 0xe0, 0x03, 0xf1, 0xd1,
	0x90, 0x50, 0x9c, 0x4b, 0xdb, 0xad, 0x15, 0x88, 0x77, 0x3e, 0xf6, 0x39, 0x27, 0xff, 0xf3, 0xf3,
	0x3f, 0x86, 0x9a, 0x35, 0x21, 0xbe, 0xf8, 0x10, 0x39, 0xed, 0x20, 0x64, 0x82, 0xa1, 0x72, 0x10,
	0x12, 0x8f, 0x7e, 0x33, 0xf7, 0x41, 0xeb, 0xd3, 0x31, 0xe1, 0xc2, 0x1e, 0x07, 0xc8, 0x80, 0x0a,
	0x27, 0x2e, 0xf3, 0x3d, 0x6e, 0x28, 0x4d, 0xa5, 0xa5, 0xe2, 0x2c, 0x44, 0xeb, 0x50, 0xf2, 0x6d,
	0x9f, 0x71, 0xa3, 0xd0, 0x54, 0x5a, 0x25, 0x9c, 0x04, 0xe6, 0xcf, 0x02, 0x54, 0xce, 0x08, 0xe7,
	0xf6, 0x90, 0xa0, 0x1a, 0x14, 0xa8, 0x27, 0xcb, 0x34, 0x5c, 0xa0, 0x1e, 0x42, 0x50, 0x74, 0x98,
	0x77, 0x23, 0x0b, 0x56, 0xb1, 0x5c, 0xa3, 0x2d, 0xa8, 0x7c, 0x67, 0x3e, 0x19, 0x50, 0xcf, 0x50,
	0x65, 0x62, 0x39, 0x0e, 0x4f, 0x3c, 0xb4, 0x0b, 0x45, 0x61, 0x0f, 0xb9, 0x51, 0x6c, 0xaa, 0x2d,
	0xbd, 0xf3, 0x7f, 0x3b, 0x11, 0xd7, 0x4e, 0x7b, 0xb7, 0xfb, 0xf6, 0x90, 0x5b, 0xbe, 0x08, 0x6f,
	0xb0, 0x4c, 0x43, 0x0d, 0x50, 0x47, 0xe4, 0xc6, 0x28, 0xc9, 0xd6, 0xf1, 0x32, 0xd6, 0x27, 0x58,
	0x40, 0x5d, 0xa3, 0x2c, 0xfb, 0x26, 0x01, 0xda, 0x01, 0x2d, 0xb0, 0x43, 0x41, 0x05, 0x65, 0xbe,
	0x51, 0x91, 0xca, 0xa7, 0x1b, 0x68, 0x13, 0xca, 0xec, 0xf2, 0x92, 0x13, 0x61, 0x54, 0xe5, 0xb0,
	0x69, 0x84, 0x9e, 0x83, 0x26, 0x32, 0x24, 0x86, 0xd6, 0x54, 0x5a, 0x7a, 0x67, 0x2d, 0x53, 0x94,
	0xb3, 0xc2, 0xd3, 0x9c, 0xed, 0x57, 0xa0, 0xe5, 0x0a, 0x33, 0x6d, 0x09, 0x88, 0x4c, 0xdb, 0xc4,
	0xbe, 0x8e, 0x88, 0x44, 0xa1, 0xe1, 0x24, 0x78, 0x53, 0x78, 0xad, 0x98, 0xbf, 0x0a, 0xa0, 0x76,
	0xdd, 0xd1, 0x1d, 0x76, 0x1d, 0xd0, 0xb9, 0xb0, 0x45, 0xc4, 0x07, 0x2e, 0xf3, 0x92, 0xba, 0xda,
	0x54, 0x43, 0xd7, 0x1d, 0xf5, 0xe4, 0x29, 0x86, 0x24, 0xeb, 0x90, 0x79, 0x24, 0xe6, 0xed, 0x11,
	0xee, 0xa6, 0x60, 0xe5, 0x7a, 0x4a, 0xa5, 0xb8, 0x94, 0x4a, 0x69, 0x39, 0x95, 0xf2, 0x72, 0x2a,
	0x95, 0x3f, 0x53, 0xc9, 0x0d, 0x50, 0x5d, 0x6c, 0x00, 0x6d, 0xce, 0x00, 0x8f, 0x53, 0x03, 0x80,
	0x34, 0xc0, 0xc6, 0xcc, 0xa8, 0xcb, 0x2e, 0x5f, 0xcf, 0x2f, 0xff, 0xdf, 0xf9, 0xef, 0x42, 0x35,
	0xb5, 0x18, 0x47, 0x8f, 0x40, 0x1d, 0xf3, 0xa1, 0xa1, 0x48, 0x01, 0xf5, 0x5b, 0x0e, 0xc4, 0xf1,
	0x99, 0xf9, 0x0e, 0x6a, 0x17, 0x91, 0x73, 0x4d, 0xf9, 0x15, 0x26, 0x5f, 0x23, 0xc2, 0x05, 0x7a,
	0x06, 0xd5, 0x71, 0xda, 0x40, 0x7e, 0x51, 0xef, 0x34, 0x6e, 0x55, 0x72, 0x9c, 0x67, 0x98, 0x7b,
	0x50, 0xcf, 0xeb, 0x79, 0xc0, 0x7c, 0x4e, 0xd0, 0x7d, 0x50, 0x6d, 0x77, 0x94, 0x7e, 0x55, 0x9f,
	0x19, 0x1b, 0xc7, 0xfb, 0xe6, 0x4b, 0x58, 0xef, 0x45, 0x0e, 0x77, 0x43, 0x1a, 0xc4, 0x97, 0xf3,
	0xb7, 0x65, 0x0c, 0xfe, 0x9b, 0x2f, 0x4b, 0xd4, 0xce, 0xd0, 0x57, 0xe6, 0xe8, 0x3f, 0x00, 0xe0,
	0x49, 0xbe, 0x43, 0xc2, 0x14, 0xd3, 0xcc, 0x0e, 0x7a, 0x08, 0x3a, 0xf5, 0xb9, 0xb0, 0x7d, 0x77,
	0xe6, 0xdf, 0x85, 0x6c, 0xeb, 0xc4, 0x7b, 0x72, 0x06, 0x5a, 0xee, 0x4a, 0xb4, 0x0a, 0xd5, 0xee,
	0xe1, 0xa1, 0x75, 0xd1, 0xb7, 0x8e, 0x1a, 0x2b, 0xa8, 0x0e, 0xfa, 0x41, 0xf7, 0x68, 0x80, 0xad,
	0x4f, 0x9f, 0xad, 0x5e, 0xbf, 0xa1, 0xa0, 0x0d, 0x58, 0x4b, 0x83, 0x41, 0xff, 0xfc, 0x7c, 0x70,
	0xda, 0xc5, 0xef, 0xad, 0x46, 0x01, 0x01, 0x94, 0x8f, 0xbb, 0x27, 0xa7, 0xd6, 0x51, 0x43, 0xed,
	0x7c, 0x04, 0x2d, 0x05, 0x45, 0x42, 0xf4, 0x16, 0x8a, 0x9c, 0xf8, 0x1e, 0xda, 0xcc, 0xc6, 0x9c,
	0xbf, 0x83, 0xed, 0xad, 0x3b, 0xfb, 0x09, 0x24, 0x73, 0xa5, 0xa5, 0xec, 0x29, 0x9d, 0x1f, 0x0a,
	0x40, 0x6f, 0x3a, 0xca, 0x3e, 0x54, 0x42, 0xe2, 0x12, 0x3a, 0x21, 0xe8, 0x5e, 0x56, 0xb8, 0x80,
	0xd5, 0xf6, 0x6d, 0x07, 0x98, 0x2b, 0x7b, 0x0a, 0x3a, 0x86, 0x7a, 0x5a, 0xfc, 0x85, 0x8a, 0xab,
	0xae, 0x3b, 0xe2, 0x68, 0x67, 0x71, 0x93, 0x44, 0xc2, 0x82, 0x2e, 0xb1, 0xa6, 0x83, 0xa7, 0xb0,
	0xe9, 0xb2, 0x71, 0x7b, 0x48, 0xb2, 0x63, 0x12, 0x3f, 0xce, 0x57, 0x91, 0x73, 0x50, 0xcf, 0x9e,
	0xe9, 0x1e, 0x09, 0x27, 0xd4, 0x25, 0x17, 0x8a, 0x53, 0x96, 0x0f, 0xf6, 0x8b, 0xdf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x92, 0xc9, 0xa2, 0x61, 0xc2, 0x05, 0x00, 0x00,
}
